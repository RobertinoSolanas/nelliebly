ifndef::imagesdir[:imagesdir: ../images]

[[section-building-block-view]]


== Building Block View

ifdef::arc42help[]
[role="arc42help"]
****
.Content
The building block view shows the static decomposition of the system into building blocks (modules, components, subsystems, classes, interfaces, packages, libraries, frameworks, layers, partitions, tiers, functions, macros, operations, data structures, ...) as well as their dependencies (relationships, associations, ...)

This view is mandatory for every architecture documentation.
In analogy to a house this is the _floor plan_.

.Motivation
Maintain an overview of your source code by making its structure understandable through
abstraction.

This allows you to communicate with your stakeholder on an abstract level without disclosing implementation details.

.Form
The building block view is a hierarchical collection of black boxes and white boxes
(see figure below) and their descriptions.

image::05_building_blocks-EN.png["Hierarchy of building blocks"]

*Level 1* is the white box description of the overall system together with black
box descriptions of all contained building blocks.

*Level 2* zooms into some building blocks of level 1.
Thus it contains the white box description of selected building blocks of level 1, together with black box descriptions of their internal building blocks.

*Level 3* zooms into selected building blocks of level 2, and so on.


.Further Information

See https://docs.arc42.org/section-5/[Building Block View] in the arc42 documentation.

****
endif::arc42help[]

=== Whitebox Overall System

ifdef::arc42help[]
[role="arc42help"]
****
Here you describe the decomposition of the overall system using the following white box template. It contains

 * an overview diagram
 * a motivation for the decomposition
 * black box descriptions of the contained building blocks. For these we offer you alternatives:

   ** use _one_ table for a short and pragmatic overview of all contained building blocks and their interfaces
   ** use a list of black box descriptions of the building blocks according to the black box template (see below).
   Depending on your choice of tool this list could be sub-chapters (in text files), sub-pages (in a Wiki) or nested elements (in a modeling tool).


 * (optional:) important interfaces, that are not explained in the black box templates of a building block, but are very important for understanding the white box.
Since there are so many ways to specify interfaces why do not provide a specific template for them.
 In the worst case you have to specify and describe syntax, semantics, protocols, error handling,
 restrictions, versions, qualities, necessary compatibilities and many things more.
In the best case you will get away with examples or simple signatures.

****
endif::arc42help[]

[plantuml, building-blocks, png]
....
@startuml
package "routeserver" {
  [RouteserverApplication] as app
  
  package "controller" {
    [HealthController] as health
    [PoiController] as poi
  }
  
  package "model" {
    [Poi] as poiModel
  }
  
  app --> health : uses
  app --> poi : uses
  poi --> poiModel : uses
}

note right of app
  Main application class that
  bootstraps the Spring Boot app
end note

note right of health
  Provides health check endpoint
  GET /heartbeat
end note

note right of poi
  Handles points of interest requests
  GET /getPoi
end note

note right of poiModel
  Data model for POI entities
end note
@enduml
....

Motivation::

The routeserver application follows a typical Spring Boot reactive web application structure with a clear separation of concerns between controllers, models, and services. This modular approach allows for easy maintenance and extensibility.

Contained Building Blocks::
The routeserver consists of the following main building blocks:

[cols="1,2" options="header"]
|===
| **Name** | **Responsibility**
| `RouteserverApplication` | Main application class that bootstraps the Spring Boot application
| `controller` package | Contains REST controllers that handle HTTP requests and responses
| `model` package | Contains data models and domain objects
| `HealthController` | Provides health check endpoint for monitoring
| `PoiController` | Handles points of interest retrieval requests
| `Poi` | Data model representing a point of interest
|===

Important Interfaces::
The application exposes RESTful HTTP endpoints as its primary interface:
- GET /heartbeat - Health check endpoint returning HTTP 200
- GET /getPoi - Points of interest endpoint with parameters for latitude, longitude, limit, and mock mode

ifdef::arc42help[]
[role="arc42help"]
****
Insert your explanations of black boxes from level 1:

If you use tabular form you will only describe your black boxes with name and
responsibility according to the following schema:

[cols="1,2" options="header"]
|===
| **Name** | **Responsibility**
| _<black box 1>_ | _<Text>_
| _<black box 2>_ | _<Text>_
|===



If you use a list of black box descriptions then you fill in a separate black box template for every important building block .
Its headline is the name of the black box.
****
endif::arc42help[]

==== RouteserverApplication

ifdef::arc42help[]
[role="arc42help"]
****
Here you describe <black box 1>
according the the following black box template:

* Purpose/Responsibility
* Interface(s), when they are not extracted as separate paragraphs. This interfaces may include qualities and performance characteristics.
* (Optional) Quality-/Performance characteristics of the black box, e.g.availability, run time behavior, ....
* (Optional) directory/file location
* (Optional) Fulfilled requirements (if you need traceability to requirements).
* (Optional) Open issues/problems/risks

****
endif::arc42help[]

Purpose/Responsibility::
The main application class that serves as the entry point for the Spring Boot application. It initializes the application context and starts the embedded web server.

Interface(s)::
Standard Spring Boot main method signature with command-line arguments.

Quality/Performance Characteristics::
Uses Spring Boot's auto-configuration for optimal startup performance and resource utilization.

Directory/File Location::
`src/main/java/com/nelliebly/routeserver/RouteserverApplication.java`

Fulfilled Requirements::
Provides the foundation for a reactive web application using Spring WebFlux.

Open Issues/Problems/Risks::
None at this time.

==== controller package

Purpose/Responsibility::
Contains all REST controllers responsible for handling incoming HTTP requests and returning appropriate responses. Implements the API endpoints for the routing service.

Interface(s)::
Exposes RESTful HTTP endpoints for health checks and points of interest retrieval.

Quality/Performance Characteristics::
Built using Spring WebFlux for non-blocking, reactive programming model that supports high concurrency.

Directory/File Location::
`src/main/java/com/nelliebly/routeserver/controller/`

Fulfilled Requirements::
Provides REST API endpoints for external clients to interact with the routing service.

Open Issues/Problems/Risks::
Controllers are currently stateless and simple, but may need to be enhanced with authentication/authorization in the future.

==== model package

Purpose/Responsibility::
Contains domain models and data transfer objects used throughout the application.

Interface(s)::
Provides Java classes that represent data structures used in the application.

Quality/Performance Characteristics::
Uses Lombok annotations to reduce boilerplate code and improve maintainability.

Directory/File Location::
`src/main/java/com/nelliebly/routeserver/model/`

Fulfilled Requirements::
Defines the data structures for points of interest and other domain entities.

Open Issues/Problems/Risks::
Model classes are simple data containers and may need to be extended with validation logic.

==== HealthController

Purpose/Responsibility::
Implements a simple health check endpoint that returns HTTP 200 OK to indicate the service is running.

Interface(s)::
GET /heartbeat endpoint that returns an empty response with HTTP 200 status code.

Quality/Performance Characteristics::
Minimal overhead health check endpoint for monitoring and load balancing.

Directory/File Location::
`src/main/java/com/nelliebly/routeserver/controller/HealthController.java`

Fulfilled Requirements::
Provides a simple endpoint for infrastructure monitoring tools to verify service availability.

Open Issues/Problems/Risks::
None at this time.

==== PoiController

Purpose/Responsibility::
Handles requests for points of interest based on GPS coordinates. Currently implements a static mock implementation.

Interface(s)::
GET /getPoi endpoint with parameters for latitude, longitude, limit, and mock mode.

Quality/Performance Characteristics::
Returns points of interest data in JSON format with support for limiting results.

Directory/File Location::
`src/main/java/com/nelliebly/routeserver/controller/PoiController.java`

Fulfilled Requirements::
Provides an endpoint for retrieving points of interest near specific GPS coordinates.

Open Issues/Problems/Risks::
The mock implementation currently returns static data regardless of the provided coordinates. A real implementation would need to query a database or external service.

==== Poi

Purpose/Responsibility::
Data model representing a point of interest with attributes such as name, GPS coordinates, and category.

Interface(s)::
Java class with getter/setter methods for all properties.

Quality/Performance Characteristics::
Uses Lombok @Data annotation to automatically generate standard methods.

Directory/File Location::
`src/main/java/com/nelliebly/routeserver/model/Poi.java`

Fulfilled Requirements::
Defines the structure for point of interest data used throughout the application.

Open Issues/Problems/Risks::
None at this time.


=== Level 2

ifdef::arc42help[]
[role="arc42help"]
****
Here you can specify the inner structure of (some) building blocks from level 1 as white boxes.

You have to decide which building blocks of your system are important enough to justify such a detailed description.
Please prefer relevance over completeness. Specify important, surprising, risky, complex or volatile building blocks.
Leave out normal, simple, boring or standardized parts of your system
****
endif::arc42help[]

==== White Box _PoiController_

ifdef::arc42help[]
[role="arc42help"]
****
...describes the internal structure of _building block 1_.
****
endif::arc42help[]

The PoiController is responsible for handling requests related to points of interest retrieval.

_Internal Structure_:
The controller consists of:
- Static POI data list for mock implementation
- getPoi() method that handles GET requests to /getPoi
- Logic to switch between mock and real implementation (currently only mock)

_Internal Dependencies_:
- Uses the Poi model class for data representation
- Depends on Spring Web annotations for request mapping
- Uses ResponseStatusException for error handling

_Detailed Interface_:
GET /getPoi
Parameters:
- lat (double): Latitude coordinate
- lon (double): Longitude coordinate
- limit (int, optional): Maximum number of results (default: 5)
- mock (boolean, optional): Use mock data (default: true)

Returns:
- HTTP 200 with JSON array of Poi objects when mock=true
- HTTP 400 when mock=false (not implemented)

==== White Box _controller package_

The controller package contains all REST controllers organized by functional area.

_Internal Structure_:
- HealthController.java: Health check endpoints
- PoiController.java: Points of interest endpoints

_Design Principles_:
- Each controller handles a specific functional area
- Controllers are stateless and follow REST conventions
- Error handling is consistent across controllers

_Dependencies_:
- Spring WebFlux annotations for request handling
- Model classes for data representation
- Spring's ResponseEntity for HTTP responses

=== Level 3

ifdef::arc42help[]
[role="arc42help"]
****
Here you can specify the inner structure of (some) building blocks from level 2 as white boxes.

When you need more detailed levels of your architecture please copy this
part of arc42 for additional levels.
****
endif::arc42help[]

==== White Box _getPoi method_

The getPoi method in PoiController handles the core logic for points of interest retrieval.

_Method Signature_:
public List<Poi> getPoi(@RequestParam double lat, @RequestParam double lon,
        @RequestParam(defaultValue = "5") int limit, @RequestParam(defaultValue = "true") boolean mock)

_Logic Flow_:
1. Receive HTTP GET request with parameters
2. Check mock parameter value
3. If mock=true:
   - Filter static POI list (currently returns all)
   - Apply limit to results
   - Return list of Poi objects
4. If mock=false:
   - Throw ResponseStatusException with HTTP 400

_Error Handling_:
- Returns HTTP 400 when mock=false (feature not implemented)
- Parameter validation handled by Spring automatically

_Data Processing_:
- Currently no actual filtering by proximity (would be implemented in real version)
- Limit parameter controls maximum results returned
- Static data set used for demonstration purposes
