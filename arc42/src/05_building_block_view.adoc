ifndef::imagesdir[:imagesdir: ../images]

[[section-building-block-view]]


== Building Block View

ifdef::arc42help[]
[role="arc42help"]
****
.Content
The building block view shows the static decomposition of the system into building blocks (modules, components, subsystems, classes, interfaces, packages, libraries, frameworks, layers, partitions, tiers, functions, macros, operations, data structures, ...) as well as their dependencies (relationships, associations, ...)

This view is mandatory for every architecture documentation.
In analogy to a house this is the _floor plan_.

.Motivation
Maintain an overview of your source code by making its structure understandable through
abstraction.

This allows you to communicate with your stakeholder on an abstract level without disclosing implementation details.

.Form
The building block view is a hierarchical collection of black boxes and white boxes
(see figure below) and their descriptions.

image::05_building_blocks-EN.png["Hierarchy of building blocks"]

*Level 1* is the white box description of the overall system together with black
box descriptions of all contained building blocks.

*Level 2* zooms into some building blocks of level 1.
Thus it contains the white box description of selected building blocks of level 1, together with black box descriptions of their internal building blocks.

*Level 3* zooms into selected building blocks of level 2, and so on.


.Further Information

See https://docs.arc42.org/section-5/[Building Block View] in the arc42 documentation.

****
endif::arc42help[]

=== Whitebox Overall System

ifdef::arc42help[]
[role="arc42help"]
****
Here you describe the decomposition of the overall system using the following white box template. It contains

 * an overview diagram 3
 * a motivation for the decomposition
 * black box descriptions of the contained building blocks. For these we offer you alternatives:

   ** use _one_ table for a short and pragmatic overview of all contained building blocks and their interfaces
   ** use a list of black box descriptions of the building blocks according to the black box template (see below).
   Depending on your choice of tool this list could be sub-chapters (in text files), sub-pages (in a Wiki) or nested elements (in a modeling tool).


 * (optional:) important interfaces, that are not explained in the black box templates of a building block, but are very important for understanding the white box.
Since there are so many ways to specify interfaces why do not provide a specific template for them.
 In the worst case you have to specify and describe syntax, semantics, protocols, error handling,
 restrictions, versions, qualities, necessary compatibilities and many things more.
In the best case you will get away with examples or simple signatures.

****
endif::arc42help[]

[plantuml, building-blocks, png]
....
@startuml
package "routeserver" {
  [RouteserverApplication] as app
  
  package "controller" {
    [HealthController] as health
    [PoiController] as poi
    [CalculateRouteController] as route
    [LastVisitedRouteController] as lastRoutes
  }
  
  package "model" {
    [Poi] as poiModel
  }
  
  package "repository" {
    [PoiRepository] as poiRepo
  }
  
  app --> health : uses
  app --> poi : uses
  app --> route : uses
  app --> lastRoutes : uses
  poi --> poiModel : uses
  poi --> poiRepo : uses
  poiRepo --> poiModel : manages
}

note right of app
  Main application class that
  bootstraps the Spring Boot app
end note

note right of health
  Provides health check endpoint
  GET /heartbeat
end note

note right of poi
  Handles points of interest requests
  GET /getPoi
end note

note right of route
  Calculates routes between locations
  GET /calculateRoute
end note

note right of lastRoutes
  Retrieves last visited routes for users
  GET /getLastRoutes
end note

note right of poiModel
  Data model for POI entities
end note

note right of poiRepo
  Repository for POI data access
  using Spring Data JPA
end note
@enduml
....

Motivation::

The routeserver application follows a typical Spring Boot MVC application structure with a clear separation of concerns between controllers, models, and repositories. This modular approach allows for easy maintenance and extensibility.

Contained Building Blocks::
The routeserver consists of the following main building blocks:

[cols="1,2" options="header"]
|===
| **Name** | **Responsibility**
| `RouteserverApplication` | Main application class that bootstraps the Spring Boot application
| `controller` package | Contains REST controllers that handle HTTP requests and responses
| `model` package | Contains data models and domain objects
| `repository` package | Contains data access repositories
| `HealthController` | Provides health check endpoint for monitoring
| `PoiController` | Handles points of interest retrieval requests
| `CalculateRouteController` | Handles route calculation requests between start and end points
| `LastVisitedRouteController` | Handles requests for retrieving last visited routes for users
| `Poi` | Data model representing a point of interest
| `PoiRepository` | Repository interface for POI data access using Spring Data JPA
|===

Important Interfaces::
The application exposes RESTful HTTP endpoints as its primary interface:
- GET /heartbeat - Health check endpoint returning HTTP 200
- GET /getPoi - Points of interest endpoint with parameters for latitude, longitude, limit, and mock mode
- GET /calculateRoute - Route calculation endpoint with parameters for start and end locations
- GET /getLastRoutes - Last visited routes endpoint with parameter for user ID

ifdef::arc42help[]
[role="arc42help"]
****
Insert your explanations of black boxes from level 1:

If you use tabular form you will only describe your black boxes with name and
responsibility according to the following schema:

[cols="1,2" options="header"]
|===
| **Name** | **Responsibility**
| _<black box 1>_ | _<Text>_
| _<black box 2>_ | _<Text>_
|===



If you use a list of black box descriptions then you fill in a separate black box template for every important building block .
Its headline is the name of the black box.
****
endif::arc42help[]

==== RouteserverApplication

ifdef::arc42help[]
[role="arc42help"]
****
Here you describe <black box 1>
according the the following black box template:

* Purpose/Responsibility
* Interface(s), when they are not extracted as separate paragraphs. This interfaces may include qualities and performance characteristics.
* (Optional) Quality-/Performance characteristics of the black box, e.g.availability, run time behavior, ....
* (Optional) directory/file location
* (Optional) Fulfilled requirements (if you need traceability to requirements).
* (Optional) Open issues/problems/risks

****
endif::arc42help[]

Purpose/Responsibility::
The main application class that serves as the entry point for the Spring Boot application. It initializes the application context and starts the embedded web server.

Interface(s)::
Standard Spring Boot main method signature with command-line arguments.

Quality/Performance Characteristics::
Uses Spring Boot's auto-configuration for optimal startup performance and resource utilization.

Directory/File Location::
`src/main/java/com/nelliebly/routeserver/RouteserverApplication.java`

Fulfilled Requirements::
Provides the foundation for a web application using Spring MVC.

Open Issues/Problems/Risks::
None at this time.

==== controller package

Purpose/Responsibility::
Contains all REST controllers responsible for handling incoming HTTP requests and returning appropriate responses. Implements the API endpoints for the routing service.

Interface(s)::
Exposes RESTful HTTP endpoints for health checks, points of interest retrieval, route calculation, and last visited routes.

Quality/Performance Characteristics::
Built using Spring MVC for handling HTTP requests with support for JSON serialization.

Directory/File Location::
`src/main/java/com/nelliebly/routeserver/controller/`

Fulfilled Requirements::
Provides REST API endpoints for external clients to interact with the routing service.

Open Issues/Problems/Risks::
Controllers are currently stateless and simple, but may need to be enhanced with authentication/authorization in the future.

==== model package

Purpose/Responsibility::
Contains domain models and data transfer objects used throughout the application.

Interface(s)::
Provides Java classes that represent data structures used in the application.

Quality/Performance Characteristics::
Uses Lombok annotations to reduce boilerplate code and improve maintainability.

Directory/File Location::
`src/main/java/com/nelliebly/routeserver/model/`

Fulfilled Requirements::
Defines the data structures for points of interest and other domain entities.

Open Issues/Problems/Risks::
Model classes are simple data containers and may need to be extended with validation logic.

==== repository package

Purpose/Responsibility::
Contains repository interfaces for data access using Spring Data JPA.

Interface(s)::
Provides CRUD operations for domain entities through Spring Data JPA interfaces.

Quality/Performance Characteristics::
Uses Spring Data JPA to provide standardized data access patterns with minimal boilerplate code.

Directory/File Location::
`src/main/java/com/nelliebly/routeserver/repository/`

Fulfilled Requirements::
Provides data access layer for persisting and retrieving domain entities.

Open Issues/Problems/Risks::
Currently only implements basic CRUD operations; complex queries may need custom implementations.

==== HealthController

Purpose/Responsibility::
Implements a simple health check endpoint that returns HTTP 200 OK to indicate the service is running.

Interface(s)::
GET /heartbeat endpoint that returns an empty response with HTTP 200 status code.

Quality/Performance Characteristics::
Minimal overhead health check endpoint for monitoring and load balancing.

Directory/File Location::
`src/main/java/com/nelliebly/routeserver/controller/HealthController.java`

Fulfilled Requirements::
Provides a simple endpoint for infrastructure monitoring tools to verify service availability.

Open Issues/Problems/Risks::
None at this time.

==== PoiController

Purpose/Responsibility::
Handles requests for points of interest based on GPS coordinates. Supports both mock data and database access.

Interface(s)::
GET /getPoi endpoint with parameters for latitude, longitude, limit, and mock mode.

Quality/Performance Characteristics::
Returns points of interest data in JSON format with support for limiting results.

Directory/File Location::
`src/main/java/com/nelliebly/routeserver/controller/PoiController.java`

Fulfilled Requirements::
Provides an endpoint for retrieving points of interest near specific GPS coordinates.

Open Issues/Problems/Risks::
The mock implementation currently returns static data regardless of the provided coordinates. A real implementation would need to query based on proximity.

==== CalculateRouteController

Purpose/Responsibility::
Handles requests for calculating routes between a start and end location.

Interface(s)::
GET /calculateRoute endpoint with parameters for start and end locations.

Quality/Performance Characteristics::
Returns route information in JSON format with distance and duration estimates.

Directory/File Location::
`src/main/java/com/nelliebly/routeserver/controller/CalculateRouteController.java`

Fulfilled Requirements::
Provides an endpoint for calculating routes between two locations.

Open Issues/Problems/Risks::
The current implementation returns mock data. A real implementation would need to integrate with a routing algorithm or external service.

==== LastVisitedRouteController

Purpose/Responsibility::
Handles requests for retrieving a user's last visited routes.

Interface(s)::
GET /getLastRoutes endpoint with parameter for user ID.

Quality/Performance Characteristics::
Returns route history data in JSON format.

Directory/File Location::
`src/main/java/com/nelliebly/routeserver/controller/LastVisitedRouteController.java`

Fulfilled Requirements::
Provides an endpoint for retrieving a user's recently visited routes.

Open Issues/Problems/Risks::
The current implementation returns mock data. A real implementation would need to integrate with a database to store and retrieve user route history.

==== Poi

Purpose/Responsibility::
Data model representing a point of interest with attributes such as name, GPS coordinates, and category.

Interface(s)::
Java class with getter/setter methods for all properties.

Quality/Performance Characteristics::
Uses Lombok @Data annotation to automatically generate standard methods.

Directory/File Location::
`src/main/java/com/nelliebly/routeserver/model/Poi.java`

Fulfilled Requirements::
Defines the structure for point of interest data used throughout the application.

Open Issues/Problems/Risks::
None at this time.

==== PoiRepository

Purpose/Responsibility::
Repository interface for POI data access using Spring Data JPA.

Interface(s)::
Extends JpaRepository to provide CRUD operations for Poi entities.

Quality/Performance Characteristics::
Uses Spring Data JPA to provide standardized data access patterns with minimal boilerplate code.

Directory/File Location::
`src/main/java/com/nelliebly/routeserver/repository/PoiRepository.java`

Fulfilled Requirements::
Provides data access layer for persisting and retrieving POI entities.

Open Issues/Problems/Risks::
Currently only implements basic CRUD operations; complex queries may need custom implementations.


=== Level 2

ifdef::arc42help[]
[role="arc42help"]
****
Here you can specify the inner structure of (some) building blocks from level 1 as white boxes.

You have to decide which building blocks of your system are important enough to justify such a detailed description.
Please prefer relevance over completeness. Specify important, surprising, risky, complex or volatile building blocks.
Leave out normal, simple, boring or standardized parts of your system
****
endif::arc42help[]

==== White Box _PoiController_

ifdef::arc42help[]
[role="arc42help"]
****
...describes the internal structure of _building block 1_.
****
endif::arc42help[]

The PoiController is responsible for handling requests related to points of interest retrieval.

_Internal Structure_:
The controller consists of:
- Static POI data initialization in @PostConstruct method
- getPoi() method that handles GET requests to /getPoi
- Logic to switch between mock and database implementation
- initializeStaticData() method that populates the database with sample data

_Internal Dependencies_:
- Uses the Poi model class for data representation
- Depends on PoiRepository for database access
- Uses Spring Web annotations for request mapping
- Uses ResponseStatusException for error handling

_Detailed Interface_:
GET /getPoi
Parameters:
- lat (double): Latitude coordinate
- lon (double): Longitude coordinate
- limit (int, optional): Maximum number of results (default: 5)
- mock (boolean, optional): Use mock data if true, database if false (default: false)

Returns:
- HTTP 200 with JSON array of Poi objects
- HTTP 400 when parameters are invalid

==== White Box _controller package_

The controller package contains all REST controllers organized by functional area.

_Internal Structure_:
- HealthController.java: Health check endpoints
- PoiController.java: Points of interest endpoints
- CalculateRouteController.java: Route calculation endpoints
- LastVisitedRouteController.java: Last visited routes endpoints

_Design Principles_:
- Each controller handles a specific functional area
- Controllers are stateless and follow REST conventions
- Error handling is consistent across controllers

_Dependencies_:
- Spring Web annotations for request handling
- Model classes for data representation
- Spring's ResponseEntity for HTTP responses
- Repository classes for data access

==== White Box _repository package_

The repository package contains data access interfaces using Spring Data JPA.

_Internal Structure_:
- PoiRepository.java: Repository interface for Poi entities

_Design Principles_:
- Follows Spring Data JPA conventions
- Extends JpaRepository for standard CRUD operations
- Uses method naming conventions for query derivation

_Dependencies_:
- Spring Data JPA
- Model classes for entity mapping

=== Level 3

ifdef::arc42help[]
[role="arc42help"]
****
Here you can specify the inner structure of (some) building blocks from level 2 as white boxes.

When you need more detailed levels of your architecture please copy this
part of arc42 for additional levels.
****
endif::arc42help[]

==== White Box _getPoi method_

The getPoi method in PoiController handles the core logic for points of interest retrieval.

_Method Signature_:
public List<Poi> getPoi(@RequestParam double lat, @RequestParam double lon,
        @RequestParam(defaultValue = "5") int limit, @RequestParam(defaultValue = "false") boolean mock)

_Logic Flow_:
1. Receive HTTP GET request with parameters
2. Check mock parameter value
3. If mock=true:
   - Return static POI list with limit applied
4. If mock=false:
   - Retrieve POIs from database through PoiRepository
   - Apply limit to results
   - Return list of Poi objects

_Error Handling_:
- Parameter validation handled by Spring automatically
- Database errors would propagate as HTTP 500 (not currently handled explicitly)

_Data Processing_:
- Currently no actual filtering by proximity (would be implemented in real version)
- Limit parameter controls maximum results returned
- Supports both static data and database access modes
